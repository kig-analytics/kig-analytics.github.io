
<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    margin: auto;
    position: relative;
    width: 960px;
}

text {
    font: 10px sans-serif;
}

.axis path,
.axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
}

form {
    position: absolute;
    right: 10px;
    top: 10px;
}

</style>
<form>
    <label><input type="radio" name="mode" value="percent"> Percent</label>
    <label><input type="radio" name="mode" value="stacked" checked> Stacked</label>
</form>
<script src="//d3js.org/d3.v4.min.js"></script>
<script>

var n = 7, // number of layers
    m = 58, // number of samples per layer
    stack = d3.stack();


var formatPercent = d3.format(".0%");
var formatNumber = d3.format("");

// transpose data
// data = data[0].map(function(col, i) { 
//     return data.map(function(row) { 
//         return row[i] 
//     })
// });

var margin = {top: 40, right: 10, bottom: 20, left: 35},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var x = d3.scaleBand()
    .rangeRound([0, width])
    .padding(0.1)
    .align(0.1);

var x1 = d3.scaleBand()
    .padding(0.05)

var y = d3.scaleLinear()
    .rangeRound([height, 0]);

var color = d3.scaleOrdinal()
    .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


d3.csv("absorption_tracking.csv", function(d, i, columns) {
  for (i = 1, t = 0; i < columns.length; ++i) t += d[columns[i]] = +d[columns[i]];
  d.total = t;
  return d;
}, function(error, data) {
    if (error) throw error;

    layers = stack.keys(data.columns.slice(1))(data);

    console.log(layers);

    console.log(data);

    var yStackMax = d3.max(layers, function(layer) { return d3.max(layer, function(d) { return d[1]; }); }),
        yGroupMax = d3.max(layers, function(layer) { return d3.max(layer, function(d) { return d[1] - d[0]; }); });

    x.domain(data.map(function(d) { return d.Date; }));
    y.domain([0, yStackMax]);
    color.domain(layers);

    //move this
    var xAxis = d3.axisBottom()
        .scale(x)
        .tickSize(0)
        .tickPadding(6);

    //move this
    var yAxis = d3.axisLeft()
        .scale(y)
        .tickSize(2)
        .tickPadding(6);


    //PROBLEM AREA -> Not returning numbers
    var layer = svg.selectAll(".layer")
        .data(layers)
      .enter().append("g")
        .attr("class", "layer")
        .attr("id", function(d) { console.log(d.key); return d.key; })
        .style("fill", function(d, i) { return color(i); });

    var rect = layer.selectAll("rect")
        .data(function(d) { return d; })
      .enter().append("rect")
        .attr("x", function(d) {0; })
        .attr("y", function(d) { height; })
        .attr("width", x.bandwidth())
        .attr("height", 0);

    rect.transition()
        .delay(function(d, i) {return i * 10; })
        .attr("x", function(d) { x(d.data.Date); })
        .attr("y", function(d) { return y(d[1]); })
        .attr("height", function(d) { return y(d[0]) - y(d[1]); });

    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    svg.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + 0 + ",0)")
        .style("font-size", "10px")
        .call(yAxis);

    d3.selectAll("input").on("change", change);

    // var timeout = setTimeout(function() {
    //     d3.select("input[value=\"percent\"]").property("checked", true).each(change);
    //     setTimeout(function() {
    //         d3.select("input[value=\"stacked\"]").property("checked", true).each(change);
    //     }, 2000);
    // }, 2000);

    function change() {
        //clearTimeout(timeout);
        if (this.value === "stacked") transitionStacked();
        else if (this.value === "percent") transitionPercent();

    }


    // function transitionGrouped() {
    //     y.domain([0, yGroupMax]);

    //     console.log("group transition");

    //     rect.transition()
    //         .duration(500)
    //         .delay(function(d, i) { return i * 10; })
    //         .attr("x", function(d, i) { return x(i) + x.bandwidth() / n * parseInt(this.parentNode.id); })
    //         .attr("width", x.bandwidth() / n)
    //     .transition()
    //         .attr("y", function(d) { console.log(y(d[0])); console.log(y(d[1])); return height - (y(d[0]) - y(d[1])); })
    //         .attr("height", function(d) { return y(d[0]) - y(d[1]); });

    //     yAxis.tickFormat(formatNumber)
    //     svg.selectAll(".y.axis").transition()
    //         .delay(500)
    //         .duration(500)
    //         .call(yAxis)
    // }

    function transitionStacked() {
        y.domain([0, yStackMax]);

        console.log("stack transition");

        rect.transition()
            .duration(500)
            .delay(function(d, i) { return i * 10; })
            .attr("y", function(d) { return y(d[1]); })
            .attr("height", function(d) { return y(d[0]) - y(d[1]); })
        .transition()
            .attr("x", function(d, i) { return x(i); })
            .attr("width", x.bandwidth());

        yAxis.tickFormat(formatNumber)
        svg.selectAll(".y.axis").transition()
            .delay(500)
            .duration(500)
            .call(yAxis)

    }

    function transitionPercent() {
        y.domain([0, 1]);

        console.log("% transition");

        rect.transition()
            .duration(500)
            .delay(function(d, i) { return i * 10; })
            .attr("y", function(d) {
                var total = d3.sum(d3.values(d.data));
                return y(d[1] / total); })
            .attr("height", function(d) { 
                var total = d3.sum(d3.values(d.data));
                return y(d[0] / total) - y(d[1] / total); })
        .transition()
            .attr("x", function(d, i) { return x(i); })
            .attr("width", x.bandwidth());

        yAxis.tickFormat(formatPercent)

        svg.selectAll(".y.axis").transition()
            .delay(500)
            .duration(500)
            .call(yAxis)

    }
})


    


// // Inspired by Lee Byron's test data generator.
// function bumpLayer(n, o) {

//   function bump(a) {
//     var x = 1 / (.1 + Math.random()),
//         y = 2 * Math.random() - .5,
//         z = 10 / (.1 + Math.random());
//     for (var i = 0; i < n; i++) {
//       var w = (i / n - y) * z;
//       a[i] += x * Math.exp(-w * w);
//     }
//   }

//   var a = [], i;
//   for (i = 0; i < n; ++i) a[i] = o + o * Math.random();
//   for (i = 0; i < 5; ++i) bump(a);

//   return a.map(function(d, i) { return Math.max(0, d); });
// }

// d3.json('./data2.json', function(error, data){

//   //start with the first year selected
//   const chart = createChart(document.querySelector('svg'), data)

//   // append the input controls
//   const fieldset1 = d3.select('.controls').append('fieldset')
//   fieldset1.append('legend').text('Year')

//   Object.keys(data).forEach((year, index )=>{

//     const label = fieldset1.append('label')

//     label
//     .append('input')
//     .attr('type', 'radio')
//     .attr('name', 'year')
//     .attr('value', year)
//     .attr('checked', function(){
//       if (index === 0) return true
//       return null
//     })

//     label.append('span')
//     .text(year)

//     label.on('click', function(){
//       chart.updateChart(data[year], document.querySelector('input[name="graphType"]:checked').value)
//     })
//   })

//   const fieldset2 = d3.select('.controls').append('fieldset')
//   const types =  ['group', 'stack']
//   fieldset2.append('legend').text('Graph Layout')

//   types.forEach((graphType, index)=>{
//     const label = fieldset2.append('label')
//     label.append('input')
//     .attr('type', 'radio')
//     .attr('name', 'graphType')
//     .attr('value', graphType)
//     .attr('checked', function(){
//       if (index === 0) return true
//       return null
//     })
//     .on('click', ()=>{
//       chart.updateChart(data[document.querySelector('input[name="year"]:checked').value], graphType)
//     })

//     label.append('span')
//     .text(graphType)

//   })

//   // render initial chart
//   chart.updateChart(data[Object.keys(data)[0]])

// })

</script>
